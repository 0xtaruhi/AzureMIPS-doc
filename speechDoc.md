讲稿
===

尊敬的各位评委老师，下午好。我们是来自复旦大学的Azure队，本次比赛我们设计了一个顺序双发射具有11级流水的MIPS处理器。接下来请允许我们介绍一下我们的参赛作品。
（翻页、翻页）
我们的处理器是用SpinalHDL语言设计实现的。SpinalHDL是一门新兴的硬件开发语言，与Chisel类似，它以Scala作为宿主语言。
SpinalHDL开发相比于Verilog、System Verilog等传统硬件开发语言，具有可高度参数化、高度灵活性和高模块复用率的特点，而相比于Chisel，由于其不需要经过FIRRTL的中间编译层，生成出的Verilog代码更具有可读性。同时，其报错信息更加人性化，思维方式也更加贴近硬件工程师，相比于Chisel更具一定的优势。
（翻页、翻页）
接下来我们简单介绍一下我们处理器的实现。
（翻页）
这是我们处理器的前端架构图。前端部分共5级流水，主要包括取指、分支预测、取指缓冲和译码部分。处理器将指令取到后放入取指缓冲中，使得处理器的执行速度基本取决于后端的吞吐能力。
（翻页）
这是我们处理器的后端架构图。后端部分共6级流水，包括发射、读寄存器、执行和访存部分。
（翻页）
接下来我们具体地介绍一下我们处理器的流水线部分。首先是取指部分，取指部分共有4级流水，包括从ICache获得指令的3级流水和取指缓冲1级流水。我们在取指部分加入了分支预测，同时为了适应我们单周期可以执行两条访存指令的架构，我们在取指缓冲中做了一定的优化处理。请看下面的两段汇编代码：（翻页）
左边的汇编代码是来源于Stream Copy程序的源码，处理器两两一组分配执行时就不能完全发挥出单周期两条访存指令的优势。在取指缓冲进行一定处理后，右边的代码将是我们处理器“看到”的代码，访问和存储都能两两成对，充分发挥出架构优势。
接下来是译码、发射和读寄存器部分。译码为后端提供执行必要的信息，发射则用来判断组内RAW冲突等需要单发射的情况并进行单发射调度，读寄存器则需要进行旁路仲裁，从流水线或通用寄存器中仲裁出真正需要的数据并送入执行单元。在读寄存器流水中还会提前计算好分支指令的跳转地址，便于执行阶段的分支预测正确性检查。
（翻页）
执行阶段进行指令结果的计算，对访存指令而言则是对地址的计算。在整条流水线中，只有执行阶段可以于Hi/Lo寄存器进行交互，这免去了对Hi/Lo寄存器作旁路的需求。
（翻页）
我们利用参数化的优势，例化了两个代码相同但功能不同的执行单元，达到既不浪费板上珍贵硬件资源、又不带来代码冗余的目的。
（翻页）接下来是访问MMU获得物理地址这一级流水。同时我们还会对地址冲突的两条指令作单发调度。
（翻页）最后是真正访存的三级流水。CacheAccess是将处理器的访存通路“二分为四”，把DCache请求和Uncache请求分开，做到处理器核心部分的“无感访问”。
（翻页）接下来我们介绍一下分支预测部分的实现。我们借鉴了开源的RISC-V处理器玄铁910的分支预测部分，采用了Bi-Mode分支预测技术。Bi-Mode分支预测集局部与全局为一体，实现简单、性能优异。同时，其把倾向于跳转和倾向于不跳转的指令分表存储，降低了指令间的混叠。
（翻页）下表是我们测得的分支预测成绩，总分支预测准确率在88%左右。
（高速缓存）


（系统设计）
我们的处理器成功运行了PMON和uCore，可以运行他们的所有指令；完成了Linux的部分启动流程。同时我们还利用了VGA接口，实现了一个仿微信的“飞机大战”小游戏。

谢谢各位老师的耐心倾听，我们的介绍到此完毕。
